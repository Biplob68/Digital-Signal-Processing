# -*- coding: utf-8 -*-
"""Digital Signal Processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j8TOiQzfxxDjLy6FAJm-PlZgnuuvwwHv
"""

import matplotlib.pyplot as plt
import numpy as np

"""#### **1. Generate and Plot the Elementary Signals in DSP**"""

# Impulse Signal   ----> if n = 0 the signal value is 1, otherwise the vsignal value is 0.

x=[]
s = np.zeros(41)
s.shape
s[20] = 1
x= np.arange(-20, 21)

plt.title("Impulse Signal Curve")
plt.stem(x, s)
plt.legend(['Impulse signal'])
plt.show()


#Unit step ---- if n >= 0 the signal value is 1, if n<0 the signal value is 0.
s = np.ones(31)
x = np.arange(0, 31, 1)
plt.title("Unit step signal Curve")
plt.stem(x, s) 
plt.legend(['Unit step'])
plt.show()


# Ramp signal --->the signal will be increase if the input is n>=0, otherwise signal is Zero
s = []
for i in range(-10, 21):
  if i >= 0:
    s.append(i)
  else:
    s.append(0)
    
x = []
x = np.arange(-10,21)
plt.title("Ramp Signal Curve")
plt.stem(x, s)
plt.legend(['Ramp signal'])
plt.show()


# for i in range(-10, 21):
#   x.append(i)


#Exponential Signal

# Generating time data using arange function from numpy
time = np.arange(-2,2, 0.0001)
constant = 0.8

# Finding amplitude at each time
amplitude_grow = constant * np.exp(time)
amplitude_decay = constant * np.exp(-time)

# Plotting time vs amplitude using plot function from pyplot
plt.plot(time, amplitude_grow, time, amplitude_decay)


plt.title('Exponential Curve')

# Showing legends
plt.legend(['Growing Exponential','Decaying Exponential'])


# Highlighting axis at x=0 and y=0
plt.axhline(y=0, color='k')
plt.axvline(x=0, color='k')


plt.show()

"""#### **2. Compute the Linear Convolution of Two Signal** :"""

# Linera convolution of two signal 


x = [1, 2, 3, 4]   # Input signal
h = [1, 2, 3, 4]   # Impulse response

l1 = len(x)
l2 = len(h)

convolution = [0 for i in range(l1 + l2 - 1)]  # Array filled with zeros


for row in range(l1):
  for col in range(l2):
    convolution[row + col] += x[row] * h[col]

print("Linear convolution of the two signal: ")
print(convolution)

"""#### **3. Compute the cross-correlation sequence of two signals x(n) and h(n).**"""

# Cross-Correlation of two signal

x = [0,0, 2,-1,3,7,1,2,-3,0,0]      # Input signal x
y = [0, 0,1,-1,2,-2,4,1,-2,5,0,0]   # Input signal y

l1 = len(x)
l2 = len(y)

cross_correlation = [0 for i in range(l1 + l2 - 1)]   # Array(output) filled with zeros

 
y = np.flip(y) # Reverse y

for row in range(l1):
  for col in range(l2):
    cross_correlation[row + col] += x[row] * y[col]

print("Cross Correlation of the sequence:",cross_correlation)
# print(cross_correlation)

"""#### **4. Determine the autocorrelation sequence of the signal x(n).**"""

# Auto Correlation of signal x(n)

x = [1, 2, 1, 1]

x1 = x             # Cooy x into y 
x1 = np.flip(x1)    # Reverse the array y

l1 = len(x)
l2 = len(x1)

auto_correlation = [0 for i in range(l1 + l2 - 1)]   # # Array(output) filled with zeros

for row in range(l1):
  for col in range(l2):
    auto_correlation[row + col] += x[row] * x1[col]

print("Auto Correlation of signal x: ", auto_correlation)

"""#### **5. Discrete Fourier Transform (DFT) of a signal using DFT equation.**"""

# Function to find DFT of a signal x(n)
def DFT(x):
  N = len(x);
  List = []       # Declear an empty list to store value

  # Nested Loop to find out X(k)  
  for k in range(N):
    value = 0;
    for n in range(N):
      value += x[n] * np.exp((-2j * np.pi * k * n) / N) 

    List.append(value)   
  return List   


# Main body Function

x = [2, -1, 3, 7, 1, 2, -3]   # Input Signal

dft = DFT(x)
print("DFT of The Signal x: ")
print(dft)

"""#### **6. Inverse DFT of the signal obtained in (5).**"""

# Function to find IDFT
def IDFT(List):
  N = len(List)
  x = []

  for n in range(N):
    value =0
    for k in range(N):
      value += List[k] * np.exp((2j * np.pi * k * n) / N)
    value /= N
    x.append(value)

  return x;      

# Print value of IDFT from DFT
idft = IDFT(dft)
print("Value of IDFT: ")
print(idft)
print(" ")


# Round value to check 
Array = [round(i.real) for i in idft]
print("After taking the real part rounding the double values: ")
print(Array)
print(" ")

# Cross check value
if Array == x:
  print("After Converting the DFT to IDFT the value is matched!")
else :
  print("Not macthed!")

"""##### **7. By means of the DFT and IDFT, the response of the FIR filter with impulse response h(n) to the input sequence x(n).**"""

x = [1, 2, 3, 4, 5]
h = [1, 2, 3, 4, 5]


print("Linear convolution of x and h: ")
print(np.convolve(h, x)) # using convolution library function
print(" ")

 
padding = len(h) + len(x) - 1

while True:
  if len(x) != padding:
    x.append(0)
  else:
    break

while True:
  if len(h) != padding:
    h.append(0)
  else:
    break

H = DFT(h) 
X = DFT(x) 
print("DFT of h: ")
print(H)
print(" ")
print("DFT of x: ")
print(X)
print(" ")


List = [0 for i in range(len(X))]   # List filled with zeros 

for i in range(len(X)):
  List[i] = H[i] * X[i]  

idft = IDFT(List)

print("After IDFT the value: ")
print(idft)
print(" ")

print("Again Linear convolution after performing IDFT: ")
List = [round(i.real) for i in idft]
print(List)

"""#### **8. Fast Fourier Transform (FFT) using divide and conquer approach**"""

x = [1, 2, 3, 4, 5, 6]   #Input signal
N = len(x)

#Factor: 2 rows, 3 columns
L = 2
M = 3

#Store value into array column-wise
Array = np.zeros((2, 3))
for i in range(L):
  for j in range(M):
    index = j * L
    index += i
    Array[i][j] = x[index]
         
dft = [DFT(Array[i]) for i in range(L)]

for l in range(L):
  for q in range(M):
    dft[l][q] = dft[l][q] * np.exp((-2j * np.pi * l * q) / N)
    
for j in range(M):
  col_element = [dft[i][j] for i in range(L)]
  col_element = DFT(col_element)

  for i in range(L):
    dft[i][j] = col_element[i]

Array = [] 

for i in range(len(dft)):
  for j in range(len(dft[0])):
    Array.append(dft[i][j])


print("Fast Fourier Transform(FFT) Using divide and Conquer Approach:")
print(Array)

"""#### **9. FFT of a given signal with N = 8 using Radix-2 algorithm.**"""

def radix2(y):
  
  N = len(y)
  if N == 2:            #Calculate DFT of 2 points 
    dft = DFT(y)
    return dft

  arra_even = []
  arra_odd = []  

  #Separated even and odd value into two list
  i = 0
  while i < N:
    if i%2 == 0:
      arra_even.append(y[i])
    else:
      arra_odd.append(y[i])
    i += 1

  # N/2 point DFT of x_even & x_odd   
  Array_even = radix2(arra_even) 
  Array_odd = radix2(arra_odd)    


  Array = [] 
  #Get first N / 2 terms
  k = 0
  while k < N / 2:
    Array.append( np.exp((-2j * np.pi * k) / N) * Array_odd[k] + Array_even[k]) 
    k += 1

  #Get last N / 2 terms
  k = 0
  while k < N / 2:
    Array.append(Array_even[k] - np.exp((-2j * np.pi * k) / N) * Array_odd[k])
    k += 1

  return Array   #Get full N value   


# Main body program
x = [1, 2, 3, 4, 5, 6, 7, 8]   #Input 
ans = radix2(x)
print("Fast Fourier Transform (FFT) of the signal x:")
print(" ")
print(ans)